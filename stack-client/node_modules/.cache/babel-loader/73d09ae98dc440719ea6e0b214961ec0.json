{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst os = require('os');\n\nconst tar = require('tar');\n\nconst path = require('path');\n\nconst crypto = require('crypto');\n\nconst log = require('npmlog');\n\nconst semver = require('semver');\n\nconst request = require('request');\n\nconst mkdir = require('mkdirp');\n\nconst processRelease = require('./process-release');\n\nconst win = process.platform === 'win32';\n\nconst getProxyFromURI = require('./proxy');\n\nfunction install(fs, gyp, argv, callback) {\n  var release = processRelease(argv, gyp, process.version, process.release); // ensure no double-callbacks happen\n\n  function cb(err) {\n    if (cb.done) {\n      return;\n    }\n\n    cb.done = true;\n\n    if (err) {\n      log.warn('install', 'got an error, rolling back install'); // roll-back the install if anything went wrong\n\n      gyp.commands.remove([release.versionDir], function () {\n        callback(err);\n      });\n    } else {\n      callback(null, release.version);\n    }\n  } // Determine which node dev files version we are installing\n\n\n  log.verbose('install', 'input version string %j', release.version);\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version));\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version));\n  } // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n\n\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version);\n\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      callback();\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'));\n    }\n\n    return;\n  } // flatten version into String\n\n\n  log.verbose('install', 'installing version: %s', release.versionDir); // the directory where the dev files will be installed\n\n  var devDir = path.resolve(gyp.devDir, release.versionDir); // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n    fs.stat(devDir, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n          go();\n        } else if (err.code === 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n\n        return;\n      }\n\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      var installVersionFile = path.resolve(devDir, 'installVersion');\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code !== 'ENOENT') {\n          return cb(err);\n        }\n\n        var installVersion = parseInt(ver, 10) || 0;\n        log.verbose('got \"installVersion\"', installVersion);\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling');\n          go();\n        } else {\n          log.verbose('install', 'version is good');\n          cb();\n        }\n      });\n    });\n  } else {\n    go();\n  }\n\n  function getContentSha(res, callback) {\n    var shasum = crypto.createHash('sha256');\n    res.on('data', function (chunk) {\n      shasum.update(chunk);\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'));\n    });\n  }\n\n  function go() {\n    log.verbose('ensuring nodedir is created', devDir); // first create the dir for the node dev files\n\n    mkdir(devDir, function (err, created) {\n      if (err) {\n        if (err.code === 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n\n        return;\n      }\n\n      if (created) {\n        log.verbose('created nodedir', created);\n      } // now download the node tarball\n\n\n      var tarPath = gyp.opts.tarball;\n      var badDownload = false;\n      var extractCount = 0;\n      var contentShasums = {};\n      var expectShasums = {}; // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n\n      function isValid(path) {\n        var isValid = valid(path);\n\n        if (isValid) {\n          log.verbose('extracted file from tarball', path);\n          extractCount++;\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', path);\n        }\n\n        return isValid;\n      } // download the tarball and extract!\n\n\n      if (tarPath) {\n        return tar.extract({\n          file: tarPath,\n          strip: 1,\n          filter: isValid,\n          cwd: devDir\n        }).then(afterTarball, cb);\n      }\n\n      try {\n        var req = download(gyp, process.env, release.tarballUrl);\n      } catch (e) {\n        return cb(e);\n      } // something went wrong downloading the tarball?\n\n\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.'));\n        }\n\n        badDownload = true;\n        cb(err);\n      });\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'));\n        }\n      });\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true;\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl));\n          return;\n        } // content checksum\n\n\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim();\n          contentShasums[filename] = checksum;\n          log.verbose('content checksum', filename, checksum);\n        }); // start unzipping and untaring\n\n        res.pipe(tar.extract({\n          strip: 1,\n          cwd: devDir,\n          filter: isValid\n        }).on('close', afterTarball).on('error', cb));\n      }); // invoked after the tarball has finished being extracted\n\n      function afterTarball() {\n        if (badDownload) {\n          return;\n        }\n\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'));\n        }\n\n        log.verbose('tarball', 'done parsing tarball');\n        var async = 0;\n\n        if (win) {\n          // need to download node.lib\n          async++;\n          downloadNodeLib(deref);\n        } // write the \"installVersion\" file\n\n\n        async++;\n        var installVersionPath = path.resolve(devDir, 'installVersion');\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref); // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n\n        if (!tarPath || win) {\n          // download SHASUMS.txt\n          async++;\n          downloadShasums(deref);\n        }\n\n        if (async === 0) {\n          // no async tasks required\n          cb();\n        }\n\n        function deref(err) {\n          if (err) {\n            return cb(err);\n          }\n\n          async--;\n\n          if (!async) {\n            log.verbose('download contents checksum', JSON.stringify(contentShasums)); // check content shasums\n\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]));\n                return;\n              }\n            }\n\n            cb();\n          }\n        }\n      }\n\n      function downloadShasums(done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n        log.verbose('checksum url', release.shasumsUrl);\n\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl);\n        } catch (e) {\n          return cb(e);\n        }\n\n        req.on('error', done);\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'));\n            return;\n          }\n\n          var chunks = [];\n          res.on('data', function (chunk) {\n            chunks.push(chunk);\n          });\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n');\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/);\n\n              if (items.length !== 2) {\n                return;\n              } // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n\n\n              var name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            });\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n            done();\n          });\n        });\n      }\n\n      function downloadNodeLib(done) {\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n        var archs = ['ia32', 'x64', 'arm64'];\n        var async = archs.length;\n        archs.forEach(function (arch) {\n          var dir = path.resolve(devDir, arch);\n          var targetLibPath = path.resolve(dir, release.name + '.lib');\n          var libUrl = release[arch].libUrl;\n          var libPath = release[arch].libPath;\n          var name = arch + ' ' + release.name + '.lib';\n          log.verbose(name, 'dir', dir);\n          log.verbose(name, 'url', libUrl);\n          mkdir(dir, function (err) {\n            if (err) {\n              return done(err);\n            }\n\n            log.verbose('streaming', name, 'to:', targetLibPath);\n\n            try {\n              var req = download(gyp, process.env, libUrl, cb);\n            } catch (e) {\n              return cb(e);\n            }\n\n            req.on('error', done);\n            req.on('response', function (res) {\n              if (res.statusCode === 403 || res.statusCode === 404) {\n                if (arch === 'arm64') {\n                  // Arm64 is a newer platform on Windows and not all node distributions provide it.\n                  log.verbose(`${name} was not found in ${libUrl}`);\n                } else {\n                  log.warn(`${name} was not found in ${libUrl}`);\n                }\n\n                return;\n              } else if (res.statusCode !== 200) {\n                done(new Error(res.statusCode + ' status code downloading ' + name));\n                return;\n              }\n\n              getContentSha(res, function (_, checksum) {\n                contentShasums[libPath] = checksum;\n                log.verbose('content checksum', libPath, checksum);\n              });\n              var ws = fs.createWriteStream(targetLibPath);\n              ws.on('error', cb);\n              req.pipe(ws);\n            });\n            req.on('end', function () {\n              --async || done();\n            });\n          });\n        });\n      } // downloadNodeLib()\n\n    }); // mkdir()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n\n  function valid(file) {\n    // header files\n    var extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n\n  function eaccesFallback(err) {\n    var noretry = '--node_gyp_internal_noretry';\n\n    if (argv.indexOf(noretry) !== -1) {\n      return cb(err);\n    }\n\n    var tmpdir = os.tmpdir();\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n    var userString = '';\n\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`;\n    } catch (e) {}\n\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n      gyp.todo.push({\n        name: 'remove',\n        args: argv\n      });\n    }\n\n    gyp.commands.install([noretry].concat(argv), cb);\n  }\n}\n\nfunction download(gyp, env, url) {\n  log.http('GET', url);\n  var requestOpts = {\n    uri: url,\n    headers: {\n      'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')',\n      Connection: 'keep-alive'\n    }\n  };\n  var cafile = gyp.opts.cafile;\n\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile);\n  } // basic support for a proxy server\n\n\n  var proxyUrl = getProxyFromURI(gyp, env, url);\n\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl);\n      requestOpts.proxy = proxyUrl;\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n    }\n  }\n\n  var req = request(requestOpts);\n  req.on('response', function (res) {\n    log.http(res.statusCode, url);\n  });\n  return req;\n}\n\nfunction readCAFile(filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8');\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n  return ca.match(re);\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  return install(fs, gyp, argv, callback);\n};\n\nmodule.exports.test = {\n  download: download,\n  install: install,\n  readCAFile: readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"sources":["C:/Users/keuda/Desktop/react/react/project/stack-client/node_modules/node-gyp/lib/install.js"],"names":["fs","require","os","tar","path","crypto","log","semver","request","mkdir","processRelease","win","process","platform","getProxyFromURI","install","gyp","argv","callback","release","version","cb","err","done","warn","commands","remove","versionDir","verbose","Error","lt","prerelease","opts","nodedir","devDir","resolve","ensure","stat","code","go","eaccesFallback","installVersionFile","readFile","ver","installVersion","parseInt","package","getContentSha","res","shasum","createHash","on","chunk","update","digest","created","tarPath","tarball","badDownload","extractCount","contentShasums","expectShasums","isValid","valid","silly","extract","file","strip","filter","cwd","then","afterTarball","req","download","env","tarballUrl","e","statusCode","_","checksum","filename","basename","trim","pipe","async","downloadNodeLib","deref","installVersionPath","writeFile","downloadShasums","JSON","stringify","k","shasumsUrl","chunks","push","lines","Buffer","concat","toString","split","forEach","line","items","length","name","replace","archs","arch","dir","targetLibPath","libUrl","libPath","ws","createWriteStream","extname","noretry","indexOf","tmpdir","userString","userInfo","username","todo","args","url","http","requestOpts","uri","headers","Connection","cafile","ca","readCAFile","proxyUrl","test","proxy","readFileSync","re","match","module","exports","usage"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst tar = require('tar')\nconst path = require('path')\nconst crypto = require('crypto')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst request = require('request')\nconst mkdir = require('mkdirp')\nconst processRelease = require('./process-release')\nconst win = process.platform === 'win32'\nconst getProxyFromURI = require('./proxy')\n\nfunction install (fs, gyp, argv, callback) {\n  var release = processRelease(argv, gyp, process.version, process.release)\n\n  // ensure no double-callbacks happen\n  function cb (err) {\n    if (cb.done) {\n      return\n    }\n    cb.done = true\n    if (err) {\n      log.warn('install', 'got an error, rolling back install')\n      // roll-back the install if anything went wrong\n      gyp.commands.remove([release.versionDir], function () {\n        callback(err)\n      })\n    } else {\n      callback(null, release.version)\n    }\n  }\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version))\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version))\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n      callback()\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'))\n    }\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  var devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    fs.stat(devDir, function (err) {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version)\n          go()\n        } else if (err.code === 'EACCES') {\n          eaccesFallback(err)\n        } else {\n          cb(err)\n        }\n        return\n      }\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n      var installVersionFile = path.resolve(devDir, 'installVersion')\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code !== 'ENOENT') {\n          return cb(err)\n        }\n        var installVersion = parseInt(ver, 10) || 0\n        log.verbose('got \"installVersion\"', installVersion)\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling')\n          go()\n        } else {\n          log.verbose('install', 'version is good')\n          cb()\n        }\n      })\n    })\n  } else {\n    go()\n  }\n\n  function getContentSha (res, callback) {\n    var shasum = crypto.createHash('sha256')\n    res.on('data', function (chunk) {\n      shasum.update(chunk)\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'))\n    })\n  }\n\n  function go () {\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    mkdir(devDir, function (err, created) {\n      if (err) {\n        if (err.code === 'EACCES') {\n          eaccesFallback(err)\n        } else {\n          cb(err)\n        }\n        return\n      }\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n\n      // now download the node tarball\n      var tarPath = gyp.opts.tarball\n      var badDownload = false\n      var extractCount = 0\n      var contentShasums = {}\n      var expectShasums = {}\n\n      // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n      function isValid (path) {\n        var isValid = valid(path)\n        if (isValid) {\n          log.verbose('extracted file from tarball', path)\n          extractCount++\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', path)\n        }\n        return isValid\n      }\n\n      // download the tarball and extract!\n      if (tarPath) {\n        return tar.extract({\n          file: tarPath,\n          strip: 1,\n          filter: isValid,\n          cwd: devDir\n        }).then(afterTarball, cb)\n      }\n\n      try {\n        var req = download(gyp, process.env, release.tarballUrl)\n      } catch (e) {\n        return cb(e)\n      }\n\n      // something went wrong downloading the tarball?\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.'))\n        }\n        badDownload = true\n        cb(err)\n      })\n\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'))\n        }\n      })\n\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl))\n          return\n        }\n        // content checksum\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim()\n          contentShasums[filename] = checksum\n          log.verbose('content checksum', filename, checksum)\n        })\n\n        // start unzipping and untaring\n        res.pipe(tar.extract({\n          strip: 1,\n          cwd: devDir,\n          filter: isValid\n        }).on('close', afterTarball).on('error', cb))\n      })\n\n      // invoked after the tarball has finished being extracted\n      function afterTarball () {\n        if (badDownload) {\n          return\n        }\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'))\n        }\n        log.verbose('tarball', 'done parsing tarball')\n        var async = 0\n\n        if (win) {\n          // need to download node.lib\n          async++\n          downloadNodeLib(deref)\n        }\n\n        // write the \"installVersion\" file\n        async++\n        var installVersionPath = path.resolve(devDir, 'installVersion')\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref)\n\n        // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n        if (!tarPath || win) {\n          // download SHASUMS.txt\n          async++\n          downloadShasums(deref)\n        }\n\n        if (async === 0) {\n          // no async tasks required\n          cb()\n        }\n\n        function deref (err) {\n          if (err) {\n            return cb(err)\n          }\n\n          async--\n          if (!async) {\n            log.verbose('download contents checksum', JSON.stringify(contentShasums))\n            // check content shasums\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]))\n                return\n              }\n            }\n            cb()\n          }\n        }\n      }\n\n      function downloadShasums (done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n        log.verbose('checksum url', release.shasumsUrl)\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl)\n        } catch (e) {\n          return cb(e)\n        }\n\n        req.on('error', done)\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'))\n            return\n          }\n\n          var chunks = []\n          res.on('data', function (chunk) {\n            chunks.push(chunk)\n          })\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n')\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/)\n              if (items.length !== 2) {\n                return\n              }\n\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n              var name = items[1].replace(/^\\.\\//, '')\n              expectShasums[name] = items[0]\n            })\n\n            log.verbose('checksum data', JSON.stringify(expectShasums))\n            done()\n          })\n        })\n      }\n\n      function downloadNodeLib (done) {\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n        var archs = ['ia32', 'x64', 'arm64']\n        var async = archs.length\n        archs.forEach(function (arch) {\n          var dir = path.resolve(devDir, arch)\n          var targetLibPath = path.resolve(dir, release.name + '.lib')\n          var libUrl = release[arch].libUrl\n          var libPath = release[arch].libPath\n          var name = arch + ' ' + release.name + '.lib'\n          log.verbose(name, 'dir', dir)\n          log.verbose(name, 'url', libUrl)\n\n          mkdir(dir, function (err) {\n            if (err) {\n              return done(err)\n            }\n            log.verbose('streaming', name, 'to:', targetLibPath)\n\n            try {\n              var req = download(gyp, process.env, libUrl, cb)\n            } catch (e) {\n              return cb(e)\n            }\n\n            req.on('error', done)\n            req.on('response', function (res) {\n              if (res.statusCode === 403 || res.statusCode === 404) {\n                if (arch === 'arm64') {\n                  // Arm64 is a newer platform on Windows and not all node distributions provide it.\n                  log.verbose(`${name} was not found in ${libUrl}`)\n                } else {\n                  log.warn(`${name} was not found in ${libUrl}`)\n                }\n                return\n              } else if (res.statusCode !== 200) {\n                done(new Error(res.statusCode + ' status code downloading ' + name))\n                return\n              }\n\n              getContentSha(res, function (_, checksum) {\n                contentShasums[libPath] = checksum\n                log.verbose('content checksum', libPath, checksum)\n              })\n\n              var ws = fs.createWriteStream(targetLibPath)\n              ws.on('error', cb)\n              req.pipe(ws)\n            })\n            req.on('end', function () { --async || done() })\n          })\n        })\n      } // downloadNodeLib()\n    }) // mkdir()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    var extname = path.extname(file)\n    return extname === '.h' || extname === '.gypi'\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  function eaccesFallback (err) {\n    var noretry = '--node_gyp_internal_noretry'\n    if (argv.indexOf(noretry) !== -1) {\n      return cb(err)\n    }\n    var tmpdir = os.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    var userString = ''\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    gyp.commands.install([noretry].concat(argv), cb)\n  }\n}\n\nfunction download (gyp, env, url) {\n  log.http('GET', url)\n\n  var requestOpts = {\n    uri: url,\n    headers: {\n      'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')',\n      Connection: 'keep-alive'\n    }\n  }\n\n  var cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile)\n  }\n\n  // basic support for a proxy server\n  var proxyUrl = getProxyFromURI(gyp, env, url)\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl)\n      requestOpts.proxy = proxyUrl\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl)\n    }\n  }\n\n  var req = request(requestOpts)\n  req.on('response', function (res) {\n    log.http(res.statusCode, url)\n  })\n\n  return req\n}\n\nfunction readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8')\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  return install(fs, gyp, argv, callback)\n}\nmodule.exports.test = {\n  download: download,\n  install: install,\n  readCAFile: readCAFile\n}\nmodule.exports.usage = 'Install node development files for the specified node version.'\n"]},"metadata":{},"sourceType":"script"}